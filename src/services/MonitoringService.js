const { JsonPatientManager } = require('./JsonPatientManager');
const { KrolikApiClient } = require('./KrolikApiClient');
const { ConfigManager } = require('./ConfigManager');
const { TimeUtils } = require('../utils/TimeUtils');

/**
 * Servi√ßo de monitoramento de pacientes
 * Respons√°vel por verificar pacientes eleg√≠veis e coordenar o envio de mensagens
 */
class MonitoringService {
  constructor(errorHandler, configManager) {
    this.errorHandler = errorHandler;
    this.configManager = configManager;
    this.jsonPatientManager = new JsonPatientManager(errorHandler);
    this.krolikApiClient = null; // Ser√° inicializado com credenciais
    
    this.isInitialized = false;
    this.lastCheckTime = null;
    this.stats = {
      totalChecks: 0,
      patientsProcessed: 0,
      messagesSent: 0,
      errors: 0,
      lastCheck: null
    };
  }

  /**
   * Inicializa o servi√ßo de monitoramento
   */
  async initialize(krolikCredentials) {
    try {
      console.log('üîß Inicializando MonitoringService...');
      
      // Inicializar JsonPatientManager
      await this.jsonPatientManager.initialize();
      
      // Inicializar KrolikApiClient
      if (krolikCredentials) {
        this.krolikApiClient = new KrolikApiClient(
          krolikCredentials.baseURL,
          krolikCredentials.token
        );
        
        // Testar conex√£o
        await this.krolikApiClient.testConnection();
        console.log('‚úÖ Conex√£o com API CAM Krolik estabelecida');
      }
      
      this.isInitialized = true;
      console.log('‚úÖ MonitoringService inicializado');
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.initialize');
      throw error;
    }
  }

  /**
   * Executa verifica√ß√£o de pacientes eleg√≠veis
   */
  async checkEligiblePatients() {
    try {
      if (!this.isInitialized || !this.krolikApiClient) {
        throw new Error('MonitoringService n√£o inicializado ou API n√£o dispon√≠vel');
      }

      console.log('üîç Verificando pacientes eleg√≠veis...');
      
      // 1. Buscar pacientes atuais da API
      const apiPatients = await this.krolikApiClient.listWaitingAttendances();
      console.log(`üìä ${apiPatients.length} pacientes encontrados na API`);
      
      // 2. Atualizar lista de pacientes ativos
      const updateStats = await this.jsonPatientManager.updateActivePatients(apiPatients);
      console.log(`üìà Pacientes atualizados: +${updateStats.new} ~${updateStats.updated} -${updateStats.removed}`);
      
      // 3. Buscar pacientes eleg√≠veis para mensagem de 30min
      const eligible30Min = await this.getEligiblePatientsFor30MinMessage();
      console.log(`‚è∞ ${eligible30Min.length} pacientes eleg√≠veis para mensagem de 30min`);
      
      // 4. Buscar pacientes eleg√≠veis para mensagem de fim de dia
      const eligibleEndOfDay = await this.getEligiblePatientsForEndOfDayMessage();
      console.log(`üåÖ ${eligibleEndOfDay.length} pacientes eleg√≠veis para mensagem de fim de dia`);
      
      // 5. Atualizar estat√≠sticas
      this.updateStats();
      
      return {
        eligible30Min,
        eligibleEndOfDay,
        totalActive: apiPatients.length,
        updateStats
      };
      
    } catch (error) {
      this.stats.errors++;
      this.errorHandler.logError(error, 'MonitoringService.checkEligiblePatients');
      throw error;
    }
  }

  /**
   * Obt√©m pacientes eleg√≠veis para mensagem de 30 minutos
   */
  async getEligiblePatientsFor30MinMessage() {
    try {
      const activePatients = await this.jsonPatientManager.loadPatientsFromFile(
        this.jsonPatientManager.files.active
      );
      
      const eligiblePatients = [];
      
      for (const patient of activePatients) {
        // Verificar crit√©rios de elegibilidade
        if (await this.isPatientEligibleFor30MinMessage(patient)) {
          eligiblePatients.push(patient);
        }
      }
      
      return eligiblePatients;
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.getEligiblePatientsFor30MinMessage');
      return [];
    }
  }

  /**
   * Obt√©m pacientes eleg√≠veis para mensagem de fim de dia
   */
  async getEligiblePatientsForEndOfDayMessage() {
    try {
      const activePatients = await this.jsonPatientManager.loadPatientsFromFile(
        this.jsonPatientManager.files.active
      );
      
      const eligiblePatients = [];
      
      for (const patient of activePatients) {
        // Verificar crit√©rios de elegibilidade para fim de dia
        if (await this.isPatientEligibleForEndOfDayMessage(patient)) {
          eligiblePatients.push(patient);
        }
      }
      
      return eligiblePatients;
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.getEligiblePatientsForEndOfDayMessage');
      return [];
    }
  }

  /**
   * Verifica se paciente √© eleg√≠vel para mensagem de 30min
   */
  async isPatientEligibleFor30MinMessage(patient) {
    try {
      // 1. Verificar tempo de espera (30-40 minutos para evitar spam)
      if (!patient.waitTimeMinutes || patient.waitTimeMinutes < 30 || patient.waitTimeMinutes > 40) {
        return false;
      }
      
      // 2. Verificar se j√° foi processado
      if (await this.jsonPatientManager.isPatientProcessed(patient.id)) {
        return false;
      }
      
      // 3. Verificar se est√° na lista de exclus√µes
      const patientKey = this.jsonPatientManager.getPatientKey(patient);
      if (this.configManager.isAttendanceExcluded(patientKey)) {
        return false;
      }
      
      // 4. Verificar hor√°rio comercial
      if (!TimeUtils.isBusinessHours()) {
        return false;
      }
      
      // 5. Verificar dia √∫til
      if (!TimeUtils.isWorkingDay()) {
        return false;
      }
      
      // 6. Verificar se fluxo n√£o est√° pausado
      if (this.configManager.isFlowPaused()) {
        return false;
      }
      
      return true;
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.isPatientEligibleFor30MinMessage');
      return false;
    }
  }

  /**
   * Verifica se paciente √© eleg√≠vel para mensagem de fim de dia
   * TODOS os pacientes aguardando devem receber mensagem de fim de dia
   */
  async isPatientEligibleForEndOfDayMessage(patient) {
    try {
      // 1. Verificar se √© fim de dia (18h)
      if (!TimeUtils.isEndOfDayTime()) {
        return false;
      }
      
      // 2. Verificar dia √∫til
      if (!TimeUtils.isWorkingDay()) {
        return false;
      }
      
      // 3. Verificar se fluxo n√£o est√° pausado
      if (this.configManager.isFlowPaused()) {
        return false;
      }
      
      // 4. TODOS os pacientes aguardando s√£o eleg√≠veis para fim de dia
      // (removido: verifica√ß√£o de processamento e exclus√µes)
      
      return true;
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.isPatientEligibleForEndOfDayMessage');
      return false;
    }
  }

  /**
   * Envia mensagens para pacientes eleg√≠veis
   */
  async sendMessagesToEligiblePatients(eligiblePatients, messageType = '30min') {
    try {
      if (!this.krolikApiClient) {
        throw new Error('KrolikApiClient n√£o inicializado');
      }
      
      const results = {
        sent: 0,
        failed: 0,
        errors: []
      };
      
      console.log(`üì§ Enviando ${messageType} messages para ${eligiblePatients.length} pacientes...`);
      
      for (const patient of eligiblePatients) {
        try {
          // Preparar payload para envio
          const payload = {
            number: patient.phone,
            contactId: patient.contactId,
            action_card_id: this.configManager.get30MinActionCardId(), // ID do action card para 30min
            forceSend: true
          };
          
          // Enviar mensagem
          await this.krolikApiClient.sendActionCard(payload);
          
          // Marcar como processado
          await this.jsonPatientManager.markPatientAsProcessed(patient.id);
          
          // Adicionar √† lista de exclus√µes
          const patientKey = this.jsonPatientManager.getPatientKey(patient);
          this.configManager.addToExclusionList(patientKey);
          
          results.sent++;
          console.log(`‚úÖ Mensagem enviada para ${patient.name} (${patient.phone})`);
          
          // Pequena pausa entre envios para evitar spam
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          results.failed++;
          results.errors.push({
            patient: patient.name,
            phone: patient.phone,
            error: error.message
          });
          
          console.error(`‚ùå Erro ao enviar mensagem para ${patient.name}:`, error.message);
        }
      }
      
      // Atualizar estat√≠sticas
      this.stats.messagesSent += results.sent;
      this.stats.patientsProcessed += results.sent;
      
      console.log(`üìä Resultado do envio: ${results.sent} enviadas, ${results.failed} falharam`);
      
      return results;
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.sendMessagesToEligiblePatients');
      throw error;
    }
  }

  /**
   * Executa limpeza di√°ria (ap√≥s mensagens de 18h)
   */
  async executeDailyCleanup() {
    try {
      console.log('üßπ Executando limpeza di√°ria...');
      
      // Limpar todos os arquivos JSON
      await this.jsonPatientManager.clearAllFiles();
      
      // Limpar lista de exclus√µes
      this.configManager.clearExclusionList();
      
      // Resetar estat√≠sticas
      this.stats = {
        totalChecks: 0,
        patientsProcessed: 0,
        messagesSent: 0,
        errors: 0,
        lastCheck: null
      };
      
      console.log('‚úÖ Limpeza di√°ria conclu√≠da');
      
    } catch (error) {
      this.errorHandler.logError(error, 'MonitoringService.executeDailyCleanup');
      throw error;
    }
  }

  /**
   * Atualiza estat√≠sticas do servi√ßo
   */
  updateStats() {
    this.stats.totalChecks++;
    this.stats.lastCheck = new Date().toISOString();
    this.lastCheckTime = new Date();
  }

  /**
   * Obt√©m estat√≠sticas do monitoramento
   */
  getStats() {
    return {
      ...this.stats,
      isInitialized: this.isInitialized,
      lastCheckTime: this.lastCheckTime,
      jsonStats: this.jsonPatientManager.getStats()
    };
  }

  /**
   * Obt√©m status do servi√ßo
   */
  getStatus() {
    return {
      isInitialized: this.isInitialized,
      hasApiClient: !!this.krolikApiClient,
      lastCheck: this.stats.lastCheck,
      totalChecks: this.stats.totalChecks,
      messagesSent: this.stats.messagesSent,
      errors: this.stats.errors
    };
  }
}

module.exports = { MonitoringService };
